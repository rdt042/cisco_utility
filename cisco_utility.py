import sys, time, csv, pyfiglet, getpass, re, os

from colorama import Fore, Back, Style
from colorama import init
from netmiko import ConnLogOnly
from datetime import datetime
from tqdm import tqdm

# This script is used to run show commands or updates against IOS-XE and ASA devices
# It also has a file comparer function where it will show lines missing from a template compared to a running config.
# By rdt042web@gmail.com

# Version 1   - Initial release
# Version 2   - Added Nexus choice

# For colorama!
init()
SB = Style.BRIGHT
SR = Style.RESET_ALL

# Initialise variables
csvFileName = "devices.csv"
device_list = []
outputFile = "output.txt"
filetxt = "config.txt"
conf_save = ''


# --------------- COMMON FUNCTIONS START ---------------

def input_tester(msg, test, finish):
# "msg" to display on cli, "test" to run
# "finish" bool only ~True~ in case of "n" is a choice AND for an exit condition
    myinput = input(msg).lower()
    while True:
        # Below tests for nothing (fails if the bool is false - you just pressed return) or a failed regex search
        # The regex search matches the test variable
        # Eg. if not bool(myinput) or re.search('[^YyNn]', myinput): 
        if not bool(myinput) or re.search(test, myinput):
            myinput = input('Input not accpeted\nDo it again\n--> ')
            continue
        elif finish and (myinput == 'n' or myinput == 'N'): 
            sys.exit(SB + Fore.RED + 'Exiting: Please re-check and re-run when ready.' + SR)
        else:
            return myinput 
        
# Report on how many devices will be tested from the csv
def count_csv():
    global count
    with open(csvFileName) as csvFile:
        devicesDict = csv.DictReader(csvFile) 
        count = len(list(devicesDict))
        return count
        
# Read all devices from csv into device_list list.
def dev_list():
    with open(csvFileName) as csvFile:
        for row in csv.DictReader(csvFile):
            cisco_dict = {
                'host' : row['hostname'],
                'device_type' : model,
                'username' : usr,
                'password' : pwd,
                'secret' : enb,
                'allow_auto_change': aac,
                'fast_cli': False,
            }
            device_list.append(cisco_dict)
    return device_list

# Read all lines from a text file and return a list 
def read_file(filetxt):
    try:
        with open(filetxt, 'r') as file:
            lines = [line.strip() for line in file.readlines()]
        return lines
    except FileNotFoundError:
        print(f"The file {filetxt} was not found.")
        return []

# Get username and password
def getusrpass():
    # Enter password - variables are defined as globals
    global usr, pwd, enb
    usr = input('\nUsername : ')
    pwd = getpass.getpass('Device password : ')

    # Enable below if need seperate enable pass for asa. Other enable for netmiko is password
    if model == 'cisco_asa':
        enb = getpass.getpass('\nDevice enable : ')
    else:
        enb = pwd
    return usr, pwd, enb

# --------------- COMMON FUNCTIONS END ---------------
        
# Generate output for run show or send commands - not for file comparer.      
def gen_output():
    global output  # Declare 'output' a global to avoid UnboundLocalError
    
    with open(outputFile,'w') as f:
        # Print date and time of script run and commands used.
        now = datetime.now()
        dt_string = now.strftime("%d/%m/%Y %H:%M:%S")

        f.write(('-' * 60) + '\n')
        when = 'Run commenced :   ' + dt_string + '\n'
        f.write(f'This output generated by the "{os.path.basename(__file__)}" script.\n')
        f.write(f'Operational mode: {op_mode}\n')
        f.write(f'Config Save mode: {conf_save}')
        f.write('\n' + when)
        f.write(('-' * 60) + '\n')
        f.write('Commands used:\n\n')
        for item in commands: f.write(item + '\n')
        f.write(('-' * 60) + '\n')
        print()

        # Initialise time for script run report on time to execute
        t1 = time.time()  
        
        # Initialize tqdm progress bar
        with tqdm(total=len(device_list), desc="Comparing devices", ncols=100, 
               colour="yellow",bar_format='{desc}: {percentage:.0f}%|{bar}| {n}/{total}') as pbar:

            # Use Netmiko to connect to "device_list" and send "search_string"
            # Counter for tqdm colour change to recognise last device in list
            for counter, device in enumerate(device_list):
                conn = ConnLogOnly(**device)
                if conn is None:
                    # Errors will be logged in 'netmiko.log'
                    sys.exit("Logging in failed")

                # send_command - config  or  show mode - send_config_set auto uses config mode.
                output = '' # clear output for each device
                # config mode
                if type == 'c':
                    output = conn.send_config_set(commands)
                # show mode
                else:
                    for command in commands:
                        output += ('>>>>> : ' + command + '\n\n')
                        output += conn.send_command(command)
                        # Dont use visual output command separator if only 1 command
                        if len(commands) > 1:
                            output += ('\n\n' + '--------------' + '\n\n')
            
                # save config if selected
                if conf_save == 'YES': conn.save_config() 

                conn.disconnect()

                # write output to file
                wr_to_file(f, device, output)
                
                # Change color to yellow when on the last iteration
                if counter == len(device_list) - 1:
                    pbar.colour = 'green'
                
                # Update tqdm progress bar
                pbar.update(1)
      
    t2 = time.time()  
    print('-' * 40)
    print()
    print(f'Script run time is {t2-t1:.1f} seconds') # .1f means to 1 decimal place
    print('Output saved to ' + SB + Fore.YELLOW + f'{outputFile}' + SR)

# Write output to file centred in a column 58 wide
def wr_to_file(file, device, output):
    file.write('\n')
    file.write(('-' * 60) + '\n')
    file.write(f"#{device['host']:^58}#" + '\n')
    file.write('\n')
    file.write(output)
    file.write('\n')

# Compare file against running configs    
def compare():
    # Count csv file devices
    count_csv()
    print(f'\nLoaded {count} devices from {csvFileName} to run the comparisons on.')

    # Get username and password
    getusrpass()

    # Run dev_list function to create device_list 
    device_list = dev_list()

    with open(outputFile,'w') as f:
        # Print date and time of script run and commands used.
        now = datetime.now()
        dt_string = now.strftime("%d/%m/%Y %H:%M:%S")

        f.write(('-' * 60) + '\n')
        when = 'Run commenced :   ' + dt_string + '\n'
        f.write(f'This output generated by the "{os.path.basename(__file__)}" script.\n')
        f.write('\n' + when)
        f.write(('-' * 60) + '\n')
        print()

        command = 'sh run'
                
        with tqdm(total=len(device_list), desc="Comparing devices", ncols=100, 
                 colour='yellow', bar_format='{desc}: {percentage:.0f}%|{bar}| {n}/{total}') as pbar:
            
            # Use Netmiko to connect to devices in device_list
            for counter, device in enumerate(device_list):
                conn = ConnLogOnly(**device)
                if conn is None:
                    # Errors will be logged in 'netmiko.log'
                    sys.exit("Logging in failed")
            
                output = ''  # clear output for each device
                output = conn.send_command(command)
                conn.disconnect()

                template_file = 'template.txt'
                device_name = device['host']

                with open(template_file, 'r') as tf:
                    template_lines = [line.strip() for line in tf.readlines() if line.strip()]
                
                output_lines = [line.strip() for line in output.splitlines() if line.strip()]

                # Find lines in template missing from the output
                not_found_in_output = find_diffs(template_lines, output_lines)

                # write device header into file
                f.write('\n')
                f.write(('-' * 60) + '\n')
                f.write(f"#{device_name:^58}#" + '\n')
                f.write('\n')

                # write output 
                f.write(f'\nLines in the template file missing in {device_name}:\n')
                for line in not_found_in_output:
                    f.write('  ' + line + '\n')

                if counter == len(device_list) - 1:
                    pbar.colour = 'green'

                pbar.update(1)

    print('\nFile comparer function finished.')       
    sys.exit('Output saved to ' + SB + Fore.YELLOW + f'{outputFile}' + SR)

# Find differences: lines not in template
def find_diffs(source_template_lines, target_output_lines):
    diffs = []
    
    for line in source_template_lines:
        if line not in target_output_lines:
            diffs.append(line)

    return diffs
    
# --------------- MAIN ---------------

# Main
if __name__ == '__main__':
    banner = pyfiglet.figlet_format('ABC NETWORK UTILIY', font='digital')
    print(SB + Fore.GREEN + banner + SR)

    print()

    # Check devices.csv confirmation
    print('This program will pass a command or list of commands to a group of devices.')
    print(SB + Fore.RED + '  OR' + SR)
    print('Will compare a config slice or slices to multiple running configs and show the differences.')
    print('\n' + SB + Fore.CYAN + 'Confirm devices.csv is the correct list of devices to run this script on? (y/n) : ' + SR)
    print('devices.csv MUST be in the same directory this script is run from.')
    check1 = input_tester('>> : ','[^YyNn]',True)

    # Check model selection
    print('\n' + SB + Fore.CYAN + 'Are the devices you will run this script on:'  + SR)
    print('    ASAs (a):')
    print('    Routers/switches (r) : ')
    print('    Nexus switches (n):')
    model = input_tester('>> : ','[^aArRnN]',False)
    if model == 'a': 
        model = 'cisco_asa'
    elif model == 'r':
        model = 'cisco_ios'
    else:
        model = 'cisco_nxos'
        
    # Check for comparer choice
    print('\n' + SB + Fore.CYAN + 'Do you wish to use the file comparer function (f) or run show or send commands to the list of devices (s) :' + SR)
    check2 = input_tester('>> : ','[^fFsS]',False)
    if check2 == 'f':
        print(SB + Fore.MAGENTA + '\n-- File Comparer function chosen --' + SR + '\n')
        print(SB + Fore.CYAN + 'Compare a config slice or slices against running configs.'  + SR)
        print('The output will show the following post processing:')
        print('  -- Lines in the template file missing in the device --')
        print('     It will NOT show Lines in the device missing in the template file.')
        print('  Use this for config elements expected to appear once - Eg ACLs, prefix-lists, routing confg etc.')
        print(SB + Fore.CYAN + '\nConfirm template.txt has the correct reference slice(s) to compare other running configs to? (y/n) :' + SR)
        print('template.txt needs to be in the same directory this script is run from.')
        check3 = input_tester('>> : ','[^YyNn]',True)
        aac = False
        
        # Run compare function and then exit script.
        compare()

    # Config or show?
    print('\n' + SB + Fore.CYAN + 'Send a show command or commands (s) or use config mode (c)?' + SR)
    type = input_tester('>> : ','[^SsCc]',False)
    if type == 'c': 
        print('\n' + SB + Fore.YELLOW + '--- CONFIG mode selected ---' + SR)
        # Set Netmiko allow_auto_change to True. 
        # Will go into config mode and for term pager and width settings
        aac = True
        op_mode = 'CONFIG'
    else:
        print('\n' + SB + Fore.GREEN + '--- SHOW mode selected ---' + SR)
        # Set Netmiko allow_auto_change to False. 
        # I.e wont go into config mode and will use exec to just set 'terminal pager 0'
        aac = False
        op_mode = 'SHOW'

    # Save config if 'CONFIG' mode selected?
    if op_mode == 'CONFIG':
        print('\n' + SB + Fore.CYAN + 'Do you wish to save the config after the commands are run? (y/n).' + SR)
        print('Select "n" if just running a show command(s) or you dont wish to save the commands.')
        save = input_tester('>> : ','[^YyNn]',False)
        if save == 'y': 
            conf_save = 'YES'
        else: 
            conf_save = 'NO'

    # Enter commands
    print('\n' + SB + Fore.CYAN + 'Enter command(s) to send to group of devices.' + SR)
    print('You do NOT need to include "conf t".')
    if op_mode == 'CONFIG':
        print('\n' + SB + Fore.YELLOW + 'config mode' + SR + ': confirm config.txt in the same directory the script is run from with the commands to send. (y/n)')
        check4 = input_tester('>> : ','[^YyNn]',False)
        commands = read_file(filetxt)
    else:
        print('\n' + SB + Fore.GREEN + 'show mode' + SR + ': enter a single command or seperate multiple commands with a comma then return.')
        commands = [s.strip() for s in input('>> : ').split(',')]

    # Confirm list of commands
    print()
    print(f'List of {len(commands)} command(s) to be send to the devices :\n')
    for x in commands: print(x)

    check5 = input_tester('\nPlease verify the command set is fully correct? (y/n) : ', '[^YyNn]',True)

    # Get username and password
    getusrpass()

    # Count csv file devices
    count_csv()

    print(f'\nLoaded {count} devices from {csvFileName} to update the config on.')
    print('\n' + SB + Fore.CYAN + 'Output will be written to "output.txt".' + SR)
    check6 = input_tester('\nProceed? (y/n) : ', '[^YyNn]',True)
    print('\nExecuting script. Standby....')
    print()

    # Run dev_list function to create device_list 
    device_list = dev_list()

    # Generate output
    gen_output()

# ~ SCRIPT END ~

