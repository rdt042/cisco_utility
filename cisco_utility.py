import sys, time, csv, pyfiglet, getpass, re, os

from colorama import Fore, Back, Style
from colorama import init
from netmiko import ConnLogOnly
from datetime import datetime
from tqdm import tqdm

# This script is used to run show commands or updates against IOS-XE and ASA devices
# By rdt042web@gmail.com

# Version 1   - Initial release
# Version 2   - Added Nexus choice
# Version 3   - Updated tqdm last iteration description
# Version 4   - Added choice for name of output file, Other minor fixes
# Version 5   - Removed file comparer function for simplicity - plan to make its own script.+
#             - Added tqdm description choice
#             - Added input choice for show commands

# For colorama!
init()
SB = Style.BRIGHT
SR = Style.RESET_ALL

# Initialise variables
csvFileName = "devices.csv"
device_list = []
outputFile = "output.txt"
filetxt = "config.txt"
conf_save = ''


# --------------- COMMON FUNCTIONS START ---------------

def input_tester(msg, test, finish):
# "msg" to display on cli, "test" to run
# "finish" bool only ~True~ in case of "n" is a choice AND for an exit condition
    myinput = input(msg).lower()
    while True:
        # Below tests for nothing (fails if the bool is false - you just pressed return) or a failed regex search
        # The regex search matches the test variable
        # Eg. if not bool(myinput) or re.search('[^YyNn]', myinput): 
        if not bool(myinput) or re.search(test, myinput):
            myinput = input('Input not accpeted\nDo it again\n--> ')
            continue
        elif finish and (myinput == 'n' or myinput == 'N'): 
            sys.exit(SB + Fore.RED + 'Exiting: Please re-check and re-run when ready.' + SR)
        else:
            return myinput 
        
# Report on how many devices will be tested from the csv
def count_csv():
    global count
    with open(csvFileName) as csvFile:
        devicesDict = csv.DictReader(csvFile) 
        count = len(list(devicesDict))
        return count
        
# Read all devices from csv into device_list list.
def dev_list():
    with open(csvFileName) as csvFile:
        for row in csv.DictReader(csvFile):
            cisco_dict = {
                'host' : row['hostname'],
                'device_type' : model,
                'username' : usr,
                'password' : pwd,
                'secret' : enb,
                'allow_auto_change': aac,
                'fast_cli': False,
            }
            device_list.append(cisco_dict)
    return device_list

# Read all lines from a text file and return a list 
def read_file(filetxt):
    try:
        with open(filetxt, 'r') as file:
            lines = [line.strip() for line in file.readlines()]
        return lines
    except FileNotFoundError:
        print(f"The file {filetxt} was not found.")
        return []

# Get username and password
def getusrpass():
    # Enter password - variables are defined as globals
    global usr, pwd, enb
    usr = input('\nUsername : ')
    pwd = getpass.getpass('Device password : ')

    # Enable below if need seperate enable pass for asa. Other enable for netmiko is password
    if model == 'cisco_asa':
        enb = getpass.getpass('\nDevice enable : ')
    else:
        enb = pwd
    return usr, pwd, enb

# --------------- COMMON FUNCTIONS END ---------------
        
# Generate output for run show or send commands - not for file comparer.      
def gen_output():
    global output  # Declare 'output' a global to avoid UnboundLocalError
    
    with open(outputFile,'w') as f:
        # Print date and time of script run and commands used.
        now = datetime.now()
        dt_string = now.strftime("%d/%m/%Y %H:%M:%S")

        f.write(('-' * 60) + '\n')
        when = 'Run commenced :   ' + dt_string + '\n'
        f.write(f'This output generated by the "{os.path.basename(__file__)}" script.\n')
        f.write(f'Operational mode: {op_mode}\n')
        f.write(f'Config Save mode: {conf_save}')
        f.write('\n' + when)
        f.write(('-' * 60) + '\n')
        f.write('Commands used:\n\n')
        for item in commands: f.write(item + '\n')
        f.write(('-' * 60) + '\n')
        print()

        # Initialise time for script run report on time to execute
        t1 = time.time()  

        # Select tqdm description
        if type == 'c':
            tqdm_desc = 'Configuring devices'
        else:
            tqdm_desc = 'Comparing devices'
        
        # Initialize tqdm progress bar
        with tqdm(total=len(device_list), desc=tqdm_desc, ncols=100, 
               colour="yellow",bar_format='{desc}: {percentage:.0f}%|{bar}| {n}/{total}') as pbar:

            # Use Netmiko to connect to "device_list" and send "search_string"
            # Counter for tqdm colour change to recognise last device in list
            for counter, device in enumerate(device_list):
                conn = ConnLogOnly(**device)
                if conn is None:
                    # Errors will be logged in 'netmiko.log'
                    sys.exit("Logging in failed")

                # send_command - config  or  show mode - send_config_set auto uses config mode.
                output = '' # clear output for each device
                # config mode
                if type == 'c':
                    output = conn.send_config_set(commands)
                # show mode
                else:
                    for command in commands:
                        output += ('>>>>> : ' + command + '\n\n')
                        output += conn.send_command(command)
                        # Dont use visual output command separator if only 1 command
                        if len(commands) > 1:
                            output += ('\n\n' + '--------------' + '\n\n')
            
                # save config if selected
                if conf_save == 'YES': conn.save_config() 

                conn.disconnect()

                # write output to file
                wr_to_file(f, device, output)
                
                # Change color to green when on the last iteration
                if counter == len(device_list) - 1:
                    pbar.colour = 'green'
                
                # Update tqdm progress bar
                pbar.update(1)
      
    t2 = time.time()  
    print('-' * 40)
    print()
    print(f'Script run time is {t2-t1:.1f} seconds') # .1f means to 1 decimal place
    print('Output saved to ' + SB + Fore.YELLOW + f'{outputFile}' + SR)

# Write output to file centred in a column 58 wide
def wr_to_file(file, device, output):
    file.write('\n')
    file.write(('-' * 60) + '\n')
    file.write(f"#{device['host']:^58}#" + '\n')
    file.write('\n')
    file.write(output)
    file.write('\n')

# --------------- MAIN ---------------

# Main
if __name__ == '__main__':
    banner = pyfiglet.figlet_format('ABC NETWORK UTILITY', font='digital')
    print(SB + Fore.GREEN + banner + SR)

    print()

    # Check devices.csv confirmation
    print('This program will pass a command or list of commands to a group of devices.')
    print('\n' + SB + Fore.CYAN + 'Confirm devices.csv is the correct list of devices to run this script on? (y/n) : ' + SR)
    print('devices.csv MUST be in the same directory this script is run from.')
    check1 = input_tester('>> : ','[^YyNn]',True)

    # Check model selection
    print('\n' + SB + Fore.CYAN + 'Are the devices you will run this script on:'  + SR)
    print('    ASAs (a):')
    print('    Routers/switches (r) : ')
    print('    Nexus switches (n):')
    model = input_tester('>> : ','[^aArRnN]',False)
    if model == 'a': 
        model = 'cisco_asa'
    elif model == 'r':
        model = 'cisco_ios'
    else:
        model = 'cisco_nxos'
        
    # Config or show?
    print('\n' + SB + Fore.CYAN + 'Send a show command or commands (s) or use config mode (c)?' + SR)
    type = input_tester('>> : ','[^SsCc]',False)
    if type == 'c': 
        print('\n' + SB + Fore.YELLOW + '--- CONFIG mode selected ---' + SR)
        # Set Netmiko allow_auto_change to True. 
        # Will go into config mode and for term pager and width settings
        aac = True
        op_mode = 'CONFIG'
    else:
        print('\n' + SB + Fore.GREEN + '--- SHOW mode selected ---' + SR)
        # Set Netmiko allow_auto_change to False. 
        # I.e wont go into config mode and will use exec to just set 'terminal pager 0'
        aac = False
        op_mode = 'SHOW'

    # Save config if 'CONFIG' mode selected?
    if op_mode == 'CONFIG':
        print('\n' + SB + Fore.CYAN + 'Do you wish to save the config after the commands are run? (y/n).' + SR)
        save = input_tester('>> : ','[^YyNn]',False)
        if save == 'y': 
            conf_save = 'YES'
        else: 
            conf_save = 'NO'

    # Enter commands
    print('\n' + SB + Fore.CYAN + 'Enter command(s) to send to group of devices in devices.csv' + SR)
    if op_mode == 'CONFIG':
        print('You do NOT need to include "conf t".')
        print('\n' + SB + Fore.YELLOW + 'config mode' + SR + ': confirm config.txt in the same directory the script is run from with the commands to send. (y/n)')
        check4 = input_tester('>> : ','[^YyNn]',True)
        commands = read_file(filetxt)
    else:
        print('\n' + SB + Fore.GREEN + 'show mode' + SR + ': Use a single or multiple commands in one of the following ways.')
        print('\nEnter the command or commands into the cli seperating multiple commands with comma (c).')
        print('  Or...')
        print('Enter the command or commands into a config.txt file located in the same directory this script is run from (t).')
        check4 = input_tester('>> : ','[^CcTt]',True)
        if check4 == 'c': 
            print('\nEnter the command(s) into the cli:')
            commands = [s.strip() for s in input('>> : ').split(',')]
        if check4 == 't':
            commands = read_file(filetxt)

    # Confirm list of commands
    print()
    print(f'List of {len(commands)} command(s) to be send to the devices :\n')
    for x in commands: print(x)

    check5 = input_tester('\nPlease verify the command set is fully correct? (y/n) : ', '[^YyNn]',True)

    # Get username and password
    getusrpass()

    # Count csv file devices
    count_csv()

    print(f'\nLoaded {count} devices from {csvFileName} to update the config on.')

    # Choice for output file name 
    print('\n' + SB + Fore.CYAN + 'Name output file (n) or use default "output.txt" (d).' + SR)
    check6 = input_tester('>> : ','[^nNdD]',False)
    if check6 == 'n':
        outputFile = input('Name of output file >> : ')
        outputFile = outputFile + '.txt'
        check7 = input_tester(f'Confirm output file will be name {outputFile} (y/n) : ', '[^YyNn]',True)
    else:
        outputFile = "output.txt"

    # Proceed?    
    check8 = input_tester('\nProceed? (y/n) : ', '[^YyNn]',True)
    print('\nExecuting script. Standby....')
    print()

    # Run dev_list function to create device_list 
    device_list = dev_list()

    # Generate output
    gen_output()

# ~ SCRIPT END ~

